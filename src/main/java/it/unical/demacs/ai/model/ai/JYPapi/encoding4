rows(0..8).
cols(0..8).

cell(R,C) :- rows(R), cols(C).

% per salvarci i muri senza l'orientamento, proiettiamo su un predicato wallNotOr
wallNotOr(X,Y) :- wall(X,Y,_).

% i due tipi di orientamento che possono avere i muri
orientation("H").
orientation("V").

% numero di giocatori calcolato grazie agli aggregati
numPlayer(X) :- #count{ID: player(ID,_,_,_,_)} = X.


% per trovare le celle adiacenti, verso destra, sinistra, in basso e in alto. Non sono considerate adiacenti celle che hanno muri che bloccano il passaggio da una all’altra.
closeCells(R1,C,R2,C):- cell(R1,C), cell(R2,C), R2=R1+1, not wall(R1,C,"H"), not wall(R1,C-1,"H").
closeCells(R1,C,R2,C):- cell(R1,C), cell(R2,C), R2=R1-1, not wall(R2,C-1,"H"), not wall(R2,C,"H").
closeCells(R,C1,R,C2):- cell(R,C1), cell(R,C2), C2=C1+1, not wall(R, C1,"V"), not wall(R-1, C1, "V").
closeCells(R,C1,R,C2):- cell(R,C1), cell(R,C2), C2=C1-1, not wall(R-1,C2,"V"), not wall(R,C2,"V").

% definiamo gli obiettivi dei giocatori
goals("N",0,C) :- cols(C).
goals("S",8,C) :- cols(C).
goals("W",R,0) :- rows(R).
goals("E",R,8) :- rows(R).

%GUESS ----------------------------------------------------------------------------------------

% trovo una nuova posizione per il giocatore oppure un nuovo muro da piazzare (se il giocatore ha ancora muri disponibili, NW>0)
nextPos(NR,NC) | notNextPos(NR,NC)  :- cell(NR,NC), player(ID,_,_,R,C), myId(ID), closeCells(R,C,NR,NC).
newWall(R,C,Or)| notNewWall(R,C,Or) :- cell(R,C), not wallNotOr(R,C), orientation(Or), player(ID,_,NW,_,_), myId(ID), R<8, C<8, NW>0.


%CHECK ----------------------------------------------------------------------------------------

% contiamo il numero di nuove posizioni e di nuovi muri, per poi controllare che siano al massimo uno ciascuno.
numNextPos(N):- #count{NR,NC : nextPos(NR,NC)}=N.
numNewWall(N):-#count{R,C,Or : newWall(R,C,Or)}=N.

% controllo che non mi restituisca più di una nuova posizione
:- numNextPos(X), X>1.
% controllo che non mi restituisca più di un nuovo muro
:- numNewWall(X), X>1.

% controllo che se ho una nuova posizione, non ho un nuovo muro
:- numNextPos(1), not numNewWall(0).
% controllo che se ho un nuovo muro, non ho una nuova posizione
:- numNextPos(0), not numNewWall(1).

% controllo che mi venga restituita almeno una mossa tra le due possibili (muro o posizione)
:- numNextPos(0), numNewWall(0).


% controllo che il muro non si incroci con un altro (metà già fatto sopra nel guess, not wallNotOr)
:- newWall(R,C,"H"), wall(R,C+1,"H").
:- newWall(R,C,"V"), wall(R+1,C,"V").
:- newWall(R,C,"H"), wall(R,C-1,"H").
:- newWall(R,C,"V"), wall(R-1,C,"V").

% Calcoliamo ora tutti i percorsi possibili fino all’obiettivo, usando la ricorsione, partendo dal player.
% prima calcoliamo i percorsi minimi per le celle adiacenti a quella in cui si trova il player
pathCost(R1,C,R2,C,1) :- closeCells(R1,C,R2,C), player(_,_,_,R1,C), R2=R1+1, not newWall(R1,C,"H"), not newWall(R1,C-1,"H").
pathCost(R1,C,R2,C,1) :- closeCells(R1,C,R2,C), player(_,_,_,R1,C), R2=R1-1, not newWall(R2,C-1,"H"), not newWall(R2,C,"H").
pathCost(R,C1,R,C2,1) :- closeCells(R,C1,R,C2), player(_,_,_,R,C1), C2=C1+1, not newWall(R, C1,"V"), not newWall(R-1, C1, "V").
pathCost(R,C1,R,C2,1) :- closeCells(R,C1,R,C2), player(_,_,_,R,C1), C2=C1-1, not newWall(R-1,C2,"V"), not newWall(R,C2,"V").

% poi calcoliamo i percorsi minimi per le altre celle: da player che è in R1,C1 a R3,C3. L'upper bound è a 30 per evitare di rallentare troppo il programma
pathCost(R1,C1,R3,C3,Cost):- pathCost(R1,C1,R2,C2,Z), player(_,_,_,R1,C1), closeCells(R2,C2,R3,C3), Cost=Z+1, R3=R2+1, not newWall(R2,C2,"H"), not newWall(R2,C2-1,"H"), Cost<30.

pathCost(R1,C1,R3,C3,Cost):- pathCost(R1,C1,R2,C2,Z), player(_,_,_,R1,C1), closeCells(R2,C2,R3,C3), Cost=Z+1, R3=R2-1, not newWall(R3,C2-1,"H"), not newWall(R3,C2,"H"), Cost<30.

pathCost(R1,C1,R3,C3,Cost):- pathCost(R1,C1,R2,C2,Z), player(_,_,_,R1,C1), closeCells(R2,C2,R3,C3), Cost=Z+1, C3=C2+1, not newWall(R2,C2,"V"), not newWall(R2-1,C2-1,"V"), Cost<30.

pathCost(R1,C1,R3,C3,Cost):- pathCost(R1,C1,R2,C2,Z), player(_,_,_,R1,C1), closeCells(R2,C2,R3,C3), Cost=Z+1, C3=C2-1, not newWall(R2-1,C3,"V"), not newWall(R2-1,C3,"V"), Cost<30.


% calcoliamo tutti i percorsi possibili, stavolta partendo dalla nuova posizione trovata
pathCostN(R1,C,R2,C,1) :- closeCells(R1,C,R2,C), nextPos(R1,C), R2=R1+1, not newWall(R1,C,"H"), not newWall(R1,C-1,"H").
pathCostN(R1,C,R2,C,1) :- closeCells(R1,C,R2,C), nextPos(R1,C), R2=R1-1, not newWall(R2,C-1,"H"), not newWall(R2,C,"H").
pathCostN(R,C1,R,C2,1) :- closeCells(R,C1,R,C2), nextPos(R,C1), C2=C1+1, not newWall(R, C1,"V"), not newWall(R-1, C1, "V").
pathCostN(R,C1,R,C2,1) :- closeCells(R,C1,R,C2), nextPos(R,C1), C2=C1-1, not newWall(R-1,C2,"V"), not newWall(R,C2,"V").
% se la prossima posizione trovata è l'obiettivo, il costo è 0
pathCostN(R1,C1,R1,C1,0):- nextPos(R1,C1), goals(Ob,R1,C1), player(ID,Ob,_,_,_), myId(ID).

% per le celle non immediatamente successive
pathCostN(R1,C1,R3,C3,Cost) :- pathCostN(R1,C1,R2,C2,Z), nextPos(R1,C1), closeCells(R2,C2,R3,C3), Cost=Z+1, R3=R2+1, not newWall(R2,C2,"H"), not newWall(R2,C2-1,"H"), Cost<30.
pathCostN(R1,C1,R3,C3,Cost) :- pathCostN(R1,C1,R2,C2,Z), nextPos(R1,C1), closeCells(R2,C2,R3,C3), Cost=Z+1, R3=R2-1, not newWall(R3,C2-1,"H"), not newWall(R3,C2,"H"), Cost<30.
pathCostN(R1,C1,R3,C3,Cost) :- pathCostN(R1,C1,R2,C2,Z), nextPos(R1,C1), closeCells(R2,C2,R3,C3), Cost=Z+1, C3=C2+1, not newWall(R2,C2,"V"), not newWall(R2-1,C2-1,"V"), Cost<30.
pathCostN(R1,C1,R3,C3,Cost) :- pathCostN(R1,C1,R2,C2,Z), nextPos(R1,C1), closeCells(R2,C2,R3,C3), Cost=Z+1, C3=C2-1, not newWall(R2-1,C3,"V"), not newWall(R2-1,C3,"V"), Cost<30.

% fine del calcolo di tutti i percorsi


% OPTIMIZE ----------------------------------------------------------------------------------------

% controllo che se ho un nuovo muro, non chiudo la strada a un giocatore (calcolo dei percorsi minimi)
minPathCost(ID,R1,C1,R2,C2,Cost) :- pathCost(R1,C1,R2,C2,Cost), goals(Ob,R2,C2), player(ID,Ob,_,R1,C1), Cost=#min{Z: pathCost(R1,C1,R4,C4,Z), goals(Ob,R4,C4)}.

% controllo che ci sia effettivamente il cammino per tutti (con count di id)
:- numPlayer(X), #count{ID : minPathCost(ID,_,_,_,_,_)}=Z, X!=Z.

% evito di stare vicino ai bordi per avere più possibilità di muovermi
:~ nextPos(R,C), player(ID,"N",_,_,_), myId(ID), pathCost(R,C,R,4,Cost), Cost=#min{K: pathCost(R,C,R,4,K)}. [Cost@1]
:~ nextPos(R,C), player(ID,"S",_,_,_), myId(ID), pathCost(R,C,R,4,Cost), Cost=#min{K: pathCost(R,C,R,4,K)}. [Cost@1]
:~ nextPos(R,C), player(ID,"W",_,_,_), myId(ID), pathCost(R,C,4,C,Cost), Cost=#min{K: pathCost(R,C,4,C,K)}. [Cost@1]
:~ nextPos(R,C), player(ID,"E",_,_,_), myId(ID), pathCost(R,C,4,C,Cost), Cost=#min{K: pathCost(R,C,4,C,K)}. [Cost@1]

% mi calcolo il mio cammino minimo dalla nuova posizione, per poi controllare se è un buon spostamento
minPathCostNextPos(ID,R1,C1,R2,C2,Cost) :- pathCostN(R1,C1,R2,C2,Cost), goals(Ob,R2,C2), player(ID,Ob,_,_,_), myId(ID), nextPos(R1,C1), Cost=#min{Z: pathCostN(R1,C1,R4,C4,Z), goals(Ob,R4,C4)}.

% evito di allontanarmi troppo dall'obiettivo
:~ nextPos(R,C), player(ID,Ob,_,_,_), myId(ID), minPathCostNextPos(ID,R,C,_,_,Cost). [Cost@2]

% se siamo distanti più di 5 passi camminiamo
:~ minPathCost(ID,_,_,_,_,Cost), Cost>5, myId(ID), newWall(_,_,_). [1@3]

% tra i due weak costraint dell'essere lontani e vicini c'è una distanza dove se muoversi o mettere un muro è deciso a caso (per evitare di far fermare il player in una cella per mettere i muri e quindi non avanzare)
:- newWall(_,_,_), random(X), X=0.

% se metto un muro pago nel caso in cui non ostacoli un altro player
:~ minPathCost(ID,R1,C1,R2,C2,Cost), myId(ID2), ID<>ID2, player(ID,"S",_,_,_), not newWall(R1,C1-1,"H"), not wallNotOr(R1,C1-1). [1@4]
:~ minPathCost(ID,R1,C1,R2,C2,Cost), myId(ID2), ID<>ID2, player(ID,"S",_,_,_), not newWall(R1,C1,"H"), not wallNotOr(R1,C1). [1@4]
:~ minPathCost(ID,R1,C1,R2,C2,Cost), myId(ID2), ID<>ID2, player(ID,"N",_,_,_), not newWall(R1-1,C1-1,"H"), not wallNotOr(R1-1,C1-1). [1@4]
:~ minPathCost(ID,R1,C1,R2,C2,Cost), myId(ID2), ID<>ID2, player(ID,"N",_,_,_), not newWall(R1-1,C1,"H"), not wallNotOr(R1-1,C1). [1@4]
:~ minPathCost(ID,R1,C1,R2,C2,Cost), myId(ID2), ID<>ID2, player(ID,"W",_,_,_), not newWall(R1,C1-1,"V"), not wallNotOr(R1,C1-1). [1@4]
:~ minPathCost(ID,R1,C1,R2,C2,Cost), myId(ID2), ID<>ID2, player(ID,"W",_,_,_), not newWall(R1-1,C1-1,"V"), not wallNotOr(R1-1,C1-1). [1@4]
:~ minPathCost(ID,R1,C1,R2,C2,Cost), myId(ID2), ID<>ID2, player(ID,"E",_,_,_), not newWall(R1-1,C1,"V"), not wallNotOr(R1-1,C1). [1@4]
:~ minPathCost(ID,R1,C1,R2,C2,Cost), myId(ID2), ID<>ID2, player(ID,"E",_,_,_), not newWall(R1,C1,"V"), not wallNotOr(R1,C1). [1@4]


% se sono a meno di 3 passi dall'obiettivo, camminiamo
:~ minPathCost(ID,R1,C1,R2,C2,Cost), Cost<3, myId(ID), player(ID,Ob,_,_,_), goals(Ob,R2,C2), newWall(_,_,_). [2@3]
